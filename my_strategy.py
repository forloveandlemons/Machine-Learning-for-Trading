import pandas as pdimport numpy as npimport osimport matplotlib.pyplot as pltfrom collections import OrderedDictfrom util import get_data, plot_datafrom portfolio.analysis import get_portfolio_value, get_portfolio_stats, plot_normalized_datadef compute_portvals(start_date, end_date, orders_file, start_val):	mydf=pd.read_csv(orders_file)	mydf.sort(["Date"])	mydf=mydf[mydf["Date"]>=start_date]	mydf=mydf[mydf["Date"]<=end_date]		dates=pd.date_range(start_date,end_date)		#generate prices dataframe	df_prices=pd.DataFrame()		symbolSeries=mydf["Symbol"]	symbolSeries=symbolSeries.drop_duplicates()	symbolList=[]	for each in symbolSeries:		symbolList.append(each)	df_prices=get_data(symbolList, dates, addSPY=True)	df_prices.drop("SPY", axis=1, inplace=True)	df_prices["CASH"]=1		#generate trades dataframe	df_trades=df_prices.copy()	df_temp_positions=df_trades.copy()			for each in df_trades:		df_trades[each]=0	for index in range(0,len(mydf)):		trade_date=mydf["Date"].iloc[index]		symbol=mydf["Symbol"].iloc[index]		#order=1 if buy order=-1 if sell		order=2*((mydf.loc[index,'Order']=="BUY")-0.5)		shares=+mydf["Shares"].iloc[index]		df_temp_positions=df_trades.copy()		df_temp_positions.loc[trade_date,"CASH"]=start_val		df_temp_positions=df_temp_positions.cumsum()		#calculating leverage before each trade is entered		long_position=0		abs_short_position=0		cash_position=start_val		trade_value=shares*df_prices.loc[trade_date,symbol]		leverage=1.0				for each in df_temp_positions:			if (each!="CASH" and df_temp_positions.loc[trade_date,each]>0):				long_position+=trade_value				cash_position-=trade_value			if (each!="CASH" and df_temp_positions.loc[trade_date,each]<0):				abs_short_position+=trade_value				cash_position+=trade_value			leverage=(long_position+abs_short_position)/(long_position-abs_short_position+cash_position)		if leverage<=2:			df_trades.loc[trade_date,symbol]+=order*shares			df_trades.loc[trade_date,"CASH"]+=-order*shares*df_prices.loc[trade_date,symbol]				#generate position dataframe	df_positions=df_trades.copy()	df_positions.loc[start_date,"CASH"]=start_val+df_positions.loc[start_date,"CASH"]	df_positions=df_positions.cumsum()	#generate portfolio value dataframe	df_values=df_prices.mul(df_positions)	df_values=df_values.sum(axis=1)	portvals=df_values	return portvals	def simple_moving_average(start_date, end_date, df_values, window):	df_time_values=df_values.copy()	df_sma=pd.rolling_mean(df_time_values,window)	return df_smadef upper_band(start_date, end_date, df_values, window):	df_time_values=df_values.copy()	df_sma=pd.rolling_mean(df_time_values,window)	df_rolling_std=pd.rolling_std(df_time_values,window)	return df_rolling_std*2+df_sma	def lower_band(start_date, end_date, df_values, window):	df_time_values=df_values.copy()	df_sma=pd.rolling_mean(df_time_values,window)	df_rolling_std=pd.rolling_std(df_time_values,window)	return -df_rolling_std*2+df_sma	def single_trade(start_date, end_date, df_values, window, parameter_array):	#each single_trade returns the trading result given a particular combination of parameters	df_stock=df_values.copy()	df_sma=pd.rolling_mean(df_stock,window)	df_rolling_std=pd.rolling_std(df_stock,window)	df_upper=df_rolling_std*2+df_sma	df_lower=-df_rolling_std*2+df_sma	df_temp=pd.concat([df_stock, df_sma, df_upper, df_lower],  keys=['IBM', 'SMA20','Upper','Lower'], axis=1)	size=len(df_temp.index)	long_entry=[]	long_exit=[]	short_entry=[]	short_exit=[]	df_trade=pd.DataFrame(0, index=df_temp.index, columns=['trade'])	df_position=pd.DataFrame(0, index=df_temp.index, columns=['position'])	for i in range(1, size):		df_position=df_trade.cumsum()		if df_position.iloc[i-1].item()==+100:			if df_stock[i-1]<parameter_array[0]*df_sma[i-1] and df_stock[i]>parameter_array[1]*df_sma[i]:				df_trade.iloc[i]=-100				long_exit.append(df_temp.index[i])		if df_position.iloc[i-1].item()==0:			if df_stock[i-1]<parameter_array[2]*df_lower[i-1] and df_stock[i]>parameter_array[3]*df_lower[i]:				df_trade.iloc[i]=+100				long_entry.append(df_temp.index[i])			if df_stock[i-1]>parameter_array[4]*df_upper[i-1] and df_stock[i]<parameter_array[5]*df_upper[i]:				df_trade.iloc[i]=-100				short_entry.append(df_temp.index[i])		if df_position.iloc[i-1].item()==-100:			if df_stock[i-1]>parameter_array[6]*df_sma[i-1] and df_stock[i]<parameter_array[7]*df_sma[i]:				df_trade.iloc[i]=+100				short_exit.append(df_temp.index[i])	df_position=df_trade.cumsum()	return df_trade, df_position, long_entry, long_exit, short_entry, short_exit	def order_file(df_trade, orders_file):	#generate the order file	df_trade=df_trade[df_trade['trade']!=0]	size=len(df_trade)	index=range(0,size)	columns=['Date', 'Symbol', 'Order', 'Shares']	df_trade_file=pd.DataFrame(0, index=index, columns=columns)	df_trade_file['Symbol']='IBM'	df_trade_file['Shares']=100	for i in range(0, size):		df_trade_file.loc[i,'Date']=df_trade.index[i].date()		if df_trade.iloc[i].item()==100:			df_trade_file.loc[i,'Order']='BUY'		if df_trade.iloc[i].item()==-100:			df_trade_file.loc[i,'Order']='SELL'	df_trade_file.to_csv(orders_file, index=False)def mesh_array(start_val, end_val, mesh):	#create an mesh_array, for our strategy, we generate mesh array for parameters from [0.9,1.1] with step being 0.01	size=int((end_val-start_val)/mesh)+1	my_mesh_array=[]	for i in range(0,size):		my_mesh_array.append(start_val+i*mesh)	return my_mesh_array						def parameter_combination_container(parameter_combination_array):	#generate array of all combination of parameters to be tested with the first 7 fixed and the last one is the elements in the mesh array	my_parameter_combination_container=[]	for each in parameter_combination_array:		my_parameter_combination_container.append([1.1,0.9,1.1,0.9,1.0,1.1,0.9,each])	print my_parameter_combination_container	return my_parameter_combination_container	def all_trades(start_date, end_date, df_values, window, parameter_combination_container):	#given array of all parameter combinations, we loop and compare all the trades( and also compares with the Bollinger band) and keeps the one with the highest cumulative return	#start with the part 1 Bollinger	df_trade,df_position,long_entry,long_exit,short_entry,short_exit=single_trade(start_date, end_date, df_values, window, [1,1,1,1,1,1,1,1,1])	orders_file='bollinger.csv'	order_file(df_trade, orders_file)	start_port_val=10000	bollinger_portvals=compute_portvals(start_date, end_date, orders_file, start_port_val)	cum_ret, avg_daily_ret, std_daily_ret, sharpe_ratio = get_portfolio_stats(bollinger_portvals)	max_cum_ret=cum_ret	my_parameter_array=[1,1,1,1,1,1,1,1]	#then we loop through all parameter combinations	for each_array in parameter_combination_container:		#temp_parameter_array=each_array		print each_array		df_trade,df_position,long_entry,long_exit,short_entry,short_exit=single_trade(start_date, end_date, df_values, window, each_array)		orders_file='temp.csv'		order_file(df_trade, orders_file)		start_port_val=10000		strategy_portvals=compute_portvals(start_date, end_date, orders_file, start_port_val)		print strategy_portvals		daily_rets=strategy_portvals.copy()		daily_rets=(strategy_portvals/strategy_portvals.shift(1))-1		daily_rets=daily_rets.ix[1:]		std_daily_ret=daily_rets.std()		if std_daily_ret!=0 and strategy_portvals[-1]>bollinger_portvals[-1]:			cum_ret, avg_daily_ret, std_daily_ret, sharpe_ratio = get_portfolio_stats(strategy_portvals)			#compare and keeps the combination that generates the highest cumulative return    		if max_cum_ret<cum_ret:    			max_cum_ret=cum_ret    			my_parameter_array=each_array	#print my_parameter_array	return my_parameter_array			def test_run():    """Driver function."""    # Define input parameters    start_date = '2000-02-01'    end_date = '2007-12-31'    #start_val = 1000000    symbol_allocations = OrderedDict([('AXP', 0.0), ('HPQ', 0.0), ('IBM', 1.0), ('HNZ', 0.0)])  # allocations from wiki example    symbols = symbol_allocations.keys()  # list of symbols, e.g.: ['GOOG', 'AAPL', 'GLD', 'XOM']    allocs = symbol_allocations.values()  # list of allocations, e.g.: [0.2, 0.3, 0.4, 0.1]    dates = pd.date_range(start_date, end_date)    prices_all = get_data(symbols, dates)  # automatically adds SPY    prices = prices_all[symbols]  # only portfolio symbols    start_val=1*prices['IBM'][0]    prices_SPY = prices_all['SPY']  # only SPY, for comparison later    	# Get daily portfolio value    portvals = get_portfolio_value(prices, allocs, start_val=prices['IBM'][0])    if isinstance(portvals, pd.DataFrame):        portvals = portvals[portvals.columns[0]]  # if a DataFrame is returned select the first column to get a Series    df_sma20=simple_moving_average(start_date, end_date, portvals, 20)    df_upper=upper_band(start_date, end_date, portvals, 20)    df_lower=lower_band(start_date, end_date, portvals, 20)        ax = portvals.plot(fontsize=10, label='IBM',legend=True)    ax.set_xlabel("Date")    ax.set_ylabel("price")    #plot sma and bollinger bands given IBM price and time horizon    df_sma20.plot(label='SMA',ax=ax,color='y',legend=True)    df_upper.plot(label='Bollinger Bands',ax=ax,color='cyan',legend=True)    df_lower.plot(label='lower_bound',ax=ax,color='cyan', legend=False)	            #carry out the trade first do part1 bollinger and then do all_trades loop to come up with the best_parameter_array                    df_trade, df_position, long_entry, long_exit, short_entry, short_exit=single_trade(start_date, end_date, portvals, 20,[1,1,1,1,1,1,1,1])    trades=long_entry+long_exit+short_entry+short_exit    orders_file='part1.csv'    order_file(df_trade, orders_file)    start_port_val=10000    bollinger_strategy_portvals=compute_portvals(start_date, end_date, orders_file, start_port_val)    parameter_combination_array=mesh_array(0.9, 1.1, 0.001)    #my_parameter_combination_container=[[1.1,0.9,1.1,0.9,1.0,1.1,0.9,0.925]]#you can test the result i provided using this line and commenting out the next line as the next line will do the loop which takes a long time        my_parameter_combination_container=parameter_combination_container(parameter_combination_array)    best_parameter_array=all_trades(start_date, end_date, portvals, 20, my_parameter_combination_container)    my_strategy_portvals = get_portfolio_value(prices, allocs, start_val=prices['IBM'][0])    if isinstance(my_strategy_portvals, pd.DataFrame):        my_strategy_portvals = my_strategy_portvals[my_strategy_portvals.columns[0]]        #trade result given the best parameter combination    df_trade, df_position, long_entry, long_exit, short_entry, short_exit=single_trade(start_date, end_date, portvals, 20,best_parameter_array)    trades=long_entry+long_exit+short_entry+short_exit        #plot the vertical entry and exit signals    for each in long_entry:    	ax.axvline(each,color='lightgreen')	    for each in long_exit:    	ax.axvline(each,color='black')    for each in short_entry:    	ax.axvline(each,color='r')    for each in short_exit:    	ax.axvline(each,color='black')     	plt.show()            #plot normalized results for all 3: part1 bollinger, part 2 strategy & SPY    orders_file='orders.csv'    order_file(df_trade, orders_file)    start_port_val=10000    #compute portfolio values        my_strategy_portvals=compute_portvals(start_date, end_date, orders_file, start_port_val)        # Get portfolio stats    cum_ret, avg_daily_ret, std_daily_ret, sharpe_ratio = get_portfolio_stats(my_strategy_portvals)    # Simulate a SPY-only reference portfolio to get stats    prices_SPX = get_data(['SPY'], pd.date_range(start_date, end_date))    prices_SPX = prices_SPX[['SPY']]  # remove SPY    portvals_SPX = get_portfolio_value(prices_SPX, [1.0])    cum_ret_SPX, avg_daily_ret_SPX, std_daily_ret_SPX, sharpe_ratio_SPX = get_portfolio_stats(portvals_SPX)    # Compare portfolio against SPY    print "Data Range: {} to {}".format(start_date, end_date)    print    print "Sharpe Ratio of Fund: {}".format(sharpe_ratio)    print "Sharpe Ratio of SPY: {}".format(sharpe_ratio_SPX)    print    print "Cumulative Return of Fund: {}".format(cum_ret)    print "Cumulative Return of SPY: {}".format(cum_ret_SPX)    print    print "Standard Deviation of Fund: {}".format(std_daily_ret)    print "Standard Deviation of SPY: {}".format(std_daily_ret_SPX)    print    print "Average Daily Return of Fund: {}".format(avg_daily_ret)    print "Average Daily Return of SPY: {}".format(avg_daily_ret_SPX)    print    print "Final Portfolio Value: {}".format(my_strategy_portvals[-1])        #print bollinger_strategy_portvals[-1]    df_temp = pd.concat([bollinger_strategy_portvals, my_strategy_portvals, prices_SPX['SPY']],  keys=['Part1_Bollinger', 'Part2_Strategy','SPY'], axis=1)    plot_normalized_data(df_temp, title="Daily portfolio value and SPY")            if __name__ == "__main__":    test_run()