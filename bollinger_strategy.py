"""MC2-P1: Market simulator."""import pandas as pdimport numpy as npimport osimport matplotlib.pyplot as pltfrom collections import OrderedDictfrom util import get_data, plot_datafrom portfolio.analysis import get_portfolio_value, get_portfolio_stats, plot_normalized_datadef compute_portvals(start_date, end_date, orders_file, start_val):	mydf=pd.read_csv(orders_file)	mydf.sort(["Date"])	mydf=mydf[mydf["Date"]>=start_date]	mydf=mydf[mydf["Date"]<=end_date]		dates=pd.date_range(start_date,end_date)		#generate prices dataframe	df_prices=pd.DataFrame()		symbolSeries=mydf["Symbol"]	symbolSeries=symbolSeries.drop_duplicates()	symbolList=[]	for each in symbolSeries:		symbolList.append(each)	df_prices=get_data(symbolList, dates, addSPY=True)	df_prices.drop("SPY", axis=1, inplace=True)	df_prices["CASH"]=1		#generate trades dataframe	df_trades=df_prices.copy()	df_temp_positions=df_trades.copy()			for each in df_trades:		df_trades[each]=0	for index in range(0,len(mydf)):		trade_date=mydf["Date"].iloc[index]		symbol=mydf["Symbol"].iloc[index]		#order=1 if buy order=-1 if sell		order=2*((mydf.loc[index,'Order']=="BUY")-0.5)		shares=+mydf["Shares"].iloc[index]		df_temp_positions=df_trades.copy()		df_temp_positions.loc[trade_date,"CASH"]=start_val		df_temp_positions=df_temp_positions.cumsum()		#calculating leverage before each trade is entered		long_position=0		abs_short_position=0		cash_position=start_val		trade_value=shares*df_prices.loc[trade_date,symbol]		leverage=1.0				for each in df_temp_positions:			if (each!="CASH" and df_temp_positions.loc[trade_date,each]>0):				long_position+=trade_value				cash_position-=trade_value			if (each!="CASH" and df_temp_positions.loc[trade_date,each]<0):				abs_short_position+=trade_value				cash_position+=trade_value			leverage=(long_position+abs_short_position)/(long_position-abs_short_position+cash_position)		if leverage<=2:			df_trades.loc[trade_date,symbol]+=order*shares			df_trades.loc[trade_date,"CASH"]+=-order*shares*df_prices.loc[trade_date,symbol]				#generate position dataframe	df_positions=df_trades.copy()	df_positions.loc[start_date,"CASH"]=start_val+df_positions.loc[start_date,"CASH"]	df_positions=df_positions.cumsum()	#generate portfolio value dataframe	df_values=df_prices.mul(df_positions)	df_values=df_values.sum(axis=1)	portvals=df_values	return portvals	def simple_moving_average(start_date, end_date, df_values, window):	#calculate sma	df_time_values=df_values.copy()	df_sma=pd.rolling_mean(df_time_values,window)	return df_smadef upper_band(start_date, end_date, df_values, window):	#calculate upperband	df_time_values=df_values.copy()	df_sma=pd.rolling_mean(df_time_values,window)	df_rolling_std=pd.rolling_std(df_time_values,window)	return df_rolling_std*2+df_sma	def lower_band(start_date, end_date, df_values, window):	#calculate lowerband	df_time_values=df_values.copy()	df_sma=pd.rolling_mean(df_time_values,window)	df_rolling_std=pd.rolling_std(df_time_values,window)	return -df_rolling_std*2+df_sma		def all_trades(start_date, end_date, df_values, window):	#the function for implementing all exit and enter long&short trades	df_stock=df_values.copy()	df_sma=pd.rolling_mean(df_stock,window)	df_rolling_std=pd.rolling_std(df_stock,window)	df_upper=df_rolling_std*2+df_sma	df_lower=-df_rolling_std*2+df_sma	df_temp=pd.concat([df_stock, df_sma, df_upper, df_lower],  keys=['IBM', 'SMA20','Upper','Lower'], axis=1)	size=len(df_temp.index)	long_entry=[]	long_exit=[]	short_entry=[]	short_exit=[]	df_trade=pd.DataFrame(0, index=df_temp.index, columns=['trade'])	df_position=pd.DataFrame(0, index=df_temp.index, columns=['position'])		for i in range(1, size):		df_position=df_trade.cumsum()		if df_position.iloc[i-1].item()==+100:			if df_stock[i-1]<df_sma[i-1] and df_stock[i]>df_sma[i]:				df_trade.iloc[i]=-100				long_exit.append(df_temp.index[i])		if df_position.iloc[i-1].item()==0:			if df_stock[i-1]<df_lower[i-1] and df_stock[i]>df_lower[i]:				df_trade.iloc[i]=+100				long_entry.append(df_temp.index[i])			if df_stock[i-1]>df_upper[i-1] and df_stock[i]<df_upper[i]:				df_trade.iloc[i]=-100				short_entry.append(df_temp.index[i])		if df_position.iloc[i-1].item()==-100:			if df_stock[i-1]>df_sma[i-1] and df_stock[i]<df_sma[i]:				df_trade.iloc[i]=+100				short_exit.append(df_temp.index[i])	df_position=df_trade.cumsum()	return df_trade, df_position, long_entry, long_exit, short_entry, short_exit	def order_file(df_trade, orders_file):	#generate the orderfile	df_trade=df_trade[df_trade['trade']!=0]	size=len(df_trade)	index=range(0,size)	columns=['Date', 'Symbol', 'Order', 'Shares']	df_trade_file=pd.DataFrame(0, index=index, columns=columns)	df_trade_file['Symbol']='IBM'	df_trade_file['Shares']=100	for i in range(0, size):		df_trade_file.loc[i,'Date']=df_trade.index[i].date()		if df_trade.iloc[i].item()==100:			df_trade_file.loc[i,'Order']='BUY'		if df_trade.iloc[i].item()==-100:			df_trade_file.loc[i,'Order']='SELL'	df_trade_file.to_csv(orders_file, index=False)									def test_run():    """Driver function."""    # Define input parameters    start_date = '2007-12-31'    end_date = '2009-12-31'    symbol_allocations = OrderedDict([('AXP', 0.0), ('HPQ', 0.0), ('IBM', 1.0), ('HNZ', 0.0)])  # allocations from wiki example    symbols = symbol_allocations.keys()  # list of symbols, e.g.: ['GOOG', 'AAPL', 'GLD', 'XOM']    allocs = symbol_allocations.values()  # list of allocations, e.g.: [0.2, 0.3, 0.4, 0.1]    dates = pd.date_range(start_date, end_date)    prices_all = get_data(symbols, dates)  # automatically adds SPY    prices = prices_all[symbols]  # only portfolio symbols    start_val=1*prices['IBM'][0]    prices_SPY = prices_all['SPY']  # only SPY, for comparison later    	# Get daily portfolio value    portvals = get_portfolio_value(prices, allocs, start_val=prices['IBM'][0])    if isinstance(portvals, pd.DataFrame):        portvals = portvals[portvals.columns[0]]  # if a DataFrame is returned select the first column to get a Series    #generate sma, upper and lowerband value for each day given portfolio value    df_sma20=simple_moving_average(start_date, end_date, portvals, 20)    df_upper=upper_band(start_date, end_date, portvals, 20)    df_lower=lower_band(start_date, end_date, portvals, 20)    df_trade, df_position, long_entry, long_exit, short_entry, short_exit=all_trades(start_date, end_date, portvals, 20)    #trades is a list that keeps track of all trades    trades=long_entry+long_exit+short_entry+short_exit		    #plot the trade entry/exit chart, sma, bollinger band    ax = portvals.plot(fontsize=10, label='IBM',legend=True)    ax.set_xlabel("Date")    ax.set_ylabel("price")    df_sma20.plot(label='SMA',ax=ax,color='y',legend=True)    df_upper.plot(label='Bollinger Bands',ax=ax,color='cyan',legend=True)    df_lower.plot(label='lower_bound',ax=ax,color='cyan', legend=False)        #plot the vertical entry and exit signals    for each in long_entry:    	ax.axvline(each,color='lightgreen')	    for each in long_exit:    	ax.axvline(each,color='black')    for each in short_entry:    	ax.axvline(each,color='r')    for each in short_exit:    	ax.axvline(each,color='black')     	plt.show()        #generate order file    orders_file='orders.csv'    order_file(df_trade, orders_file)    start_port_val=10000    #compute portfolio values    strategy_portvals=compute_portvals(start_date, end_date, orders_file, start_port_val)    # Get portfolio stats    cum_ret, avg_daily_ret, std_daily_ret, sharpe_ratio = get_portfolio_stats(strategy_portvals)	# Simulate a SPY-only reference portfolio to get stats    prices_SPX = get_data(['SPY'], pd.date_range(start_date, end_date))    prices_SPX = prices_SPX[['SPY']]  # remove SPY    portvals_SPX = get_portfolio_value(prices_SPX, [1.0])    cum_ret_SPX, avg_daily_ret_SPX, std_daily_ret_SPX, sharpe_ratio_SPX = get_portfolio_stats(portvals_SPX)    # Compare portfolio against SPY    print "Data Range: {} to {}".format(start_date, end_date)    print    print "Sharpe Ratio of Fund: {}".format(sharpe_ratio)    print "Sharpe Ratio of SPY: {}".format(sharpe_ratio_SPX)    print    print "Cumulative Return of Fund: {}".format(cum_ret)    print "Cumulative Return of SPY: {}".format(cum_ret_SPX)    print    print "Standard Deviation of Fund: {}".format(std_daily_ret)    print "Standard Deviation of SPY: {}".format(std_daily_ret_SPX)    print    print "Average Daily Return of Fund: {}".format(avg_daily_ret)    print "Average Daily Return of SPY: {}".format(avg_daily_ret_SPX)    print    print "Final Portfolio Value: {}".format(strategy_portvals[-1])        #plot the normalized backtest chart with benchmark being spy    df_temp1 = pd.concat([strategy_portvals, prices_SPX['SPY']],  keys=['Portfolio', 'SPY'], axis=1)    plot_normalized_data(df_temp1, title="Daily portfolio value and SPY")    if __name__ == "__main__":    test_run()